using System;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

/* 
2.2.3 Certificate creation
The key pair used does not require the issuance of a certificate by an accredited entity. The systems
vendor can generate the self-signed certificate for certification and send the public key to the
Norwegian Tax Administration through the Cash Register System product declaration.
To create the certificate from the private key, RSA algorithm must be used with following
specifications on the parameters:
 - Format = x.509
 - Charset = UTF-8
 - Encoding = Base-64
 - Endianness = Little Endian
 - OAEP Padding = PKCS1 v1.5 padding
 - Private key size = 1024 bits
 - Hash Message Format = SHA-1
 
Source: https://www.skatteetaten.no/globalassets/bedrift-og-organisasjon/starte-og-drive/rutiner-regnskap-og-kassasystem/saf-t-regnskap/requirements-and-guidelines-for-implementing-digital-signatures-in-cash-register-systems.pdf
*/

namespace Softcash.SAFT
{
    public class DigitalSignature
    {
        /// <summary>
        /// Private constructor because we don't want/need people to instantiate this class as it only contains static helper functions.
        /// </summary>
        private DigitalSignature() { }

        /// <summary>
        /// A container for the data to be signed.
        /// </summary>
        public class SigningData
        {
            public string previousSignature;
            public DateTime transactionDateTime;
            public uint transactionNumber;
            public double transactionAmountIn;
            public double transactionAmountEx;

            public override string ToString()
            {
                if (previousSignature == null) { previousSignature = "0"; } // If this is the first signature created, use "0" as previous signature
                StringBuilder sb = new StringBuilder();
                sb.Append(previousSignature + ";");
                sb.Append(transactionDateTime.ToString("yyyy-MM-dd;", System.Globalization.CultureInfo.InvariantCulture));
                sb.Append(transactionDateTime.ToString("HH:mm:ss;", System.Globalization.CultureInfo.InvariantCulture));
                sb.Append(transactionNumber + ";");
                sb.Append(transactionAmountIn.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + ";");
                sb.Append(transactionAmountEx.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture));
                return sb.ToString();
            }
        }

        /// <summary>
        /// Generates a secret key (random bytes)
        /// </summary>
        /// <param name="keySize">The size of the key in bits</param>
        /// <returns>A byte array containing bytes generated by RNGCryptoServiceProvider</returns>
        public static byte[] GenerateKey(int keySize = 128)
        {
            using (RNGCryptoServiceProvider rngCrypto = new RNGCryptoServiceProvider())
            {
                var key = new byte[keySize / 8]; // Keysize in bits divided by 8 (8 bits in 1 byte)
                rngCrypto.GetNonZeroBytes(key);
                return key;
            }
        }

        /// <summary>
        /// Signs the input with the key provided
        /// </summary>
        /// <param name="input">Data to be signed</param>
        /// <param name="key">Key used for signing</param>
        /// <returns>Base64 encoded signed data</returns>
        public static string SignHMAC(byte[] input, byte[] key)
        {
            using (HMACSHA1 hmac = new HMACSHA1(key))
            {
                hmac.Initialize();
                var signature = hmac.ComputeHash(input);
                return Convert.ToBase64String(signature);
            }
        }

        /// <summary>
        /// Signs the input with the certificate/private key provided
        /// </summary>
        /// <param name="input">Data to be signed</param>
        /// <param name="certificate">Certificate/Private key used for signing</param>
        /// <returns>Base64 encoded signed data</returns>
        public static string SignRSA(byte[] input, X509Certificate2 certificate)
        {
            var hash = SHA1(input);
            using (RSA rsa = certificate.GetRSAPrivateKey())
            {
                var signature = rsa.Encrypt(hash, RSAEncryptionPadding.Pkcs1);
                return Convert.ToBase64String(signature);
            }
        }

        /// <summary>
        /// Signs the input with the key provided
        /// </summary>
        /// <param name="input">Data to be signed</param>
        /// <param name="key">Key used for signing</param>
        /// <returns>Base64 encoded signed data</returns>
        public static string SignHMAC(string input, byte[] key)
        {
            return SignHMAC(Encoding.UTF8.GetBytes(input), key);
        }

        /// <summary>
        /// Signs the input with the certificate/private key provided
        /// </summary>
        /// <param name="input">Data to be signed</param>
        /// <param name="certificate">Certificate/Private key used for signing</param>
        /// <returns>Base64 encoded signed data</returns>
        public static string SignRSA(string input, X509Certificate2 certificate)
        {
            return SignRSA(Encoding.UTF8.GetBytes(input), certificate);
        }

        /// <summary>
        /// Generates a SHA-1 hash from input data.
        /// </summary>
        /// <param name="input">Data to be hashed</param>
        /// <returns>Byte array containing hash.</returns>
        public static byte[] SHA1(byte[] input)
        {
            using (SHA1Managed sha = new SHA1Managed())
            {
                return sha.ComputeHash(input);
            }
        }
    }
}
